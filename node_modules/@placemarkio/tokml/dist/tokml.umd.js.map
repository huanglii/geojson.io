{"version":3,"file":"tokml.umd.js","sources":["../node_modules/unist-builder/index.js","../node_modules/xastscript/lib/index.js","../node_modules/xast-util-to-xml/lib/all.js","../node_modules/stringify-entities/lib/core.js","../node_modules/stringify-entities/lib/util/format-basic.js","../node_modules/xast-util-to-xml/lib/util-escape.js","../node_modules/stringify-entities/lib/index.js","../node_modules/xast-util-to-xml/lib/name.js","../node_modules/ccount/index.js","../node_modules/xast-util-to-xml/lib/value.js","../node_modules/xast-util-to-xml/lib/element.js","../node_modules/xast-util-to-xml/lib/text.js","../node_modules/xast-util-to-xml/lib/instruction.js","../node_modules/xast-util-to-xml/lib/cdata.js","../node_modules/xast-util-to-xml/lib/one.js","../node_modules/xast-util-to-xml/lib/comment.js","../node_modules/xast-util-to-xml/lib/doctype.js","../node_modules/xast-util-to-xml/lib/raw.js","../node_modules/xast-util-to-xml/lib/index.js","../lib/index.ts"],"sourcesContent":["/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist').Literal} Literal\n * @typedef {Object.<string, unknown>} Props\n * @typedef {Array.<Node>|string} ChildrenOrValue\n *\n * @typedef {(<T extends string, P extends Record<string, unknown>, C extends Node[]>(type: T, props: P, children: C) => {type: T, children: C} & P)} BuildParentWithProps\n * @typedef {(<T extends string, P extends Record<string, unknown>>(type: T, props: P, value: string) => {type: T, value: string} & P)} BuildLiteralWithProps\n * @typedef {(<T extends string, P extends Record<string, unknown>>(type: T, props: P) => {type: T} & P)} BuildVoidWithProps\n * @typedef {(<T extends string, C extends Node[]>(type: T, children: C) => {type: T, children: C})} BuildParent\n * @typedef {(<T extends string>(type: T, value: string) => {type: T, value: string})} BuildLiteral\n * @typedef {(<T extends string>(type: T) => {type: T})} BuildVoid\n */\n\nexport var u = /**\n * @type {BuildVoid & BuildVoidWithProps & BuildLiteral & BuildLiteralWithProps & BuildParent & BuildParentWithProps}\n */ (\n  /**\n   * @param {string} type Type of node\n   * @param {Props|ChildrenOrValue} [props] Additional properties for node (or `children` or `value`)\n   * @param {ChildrenOrValue} [value] `children` or `value` of node\n   * @returns {Node}\n   */\n  function (type, props, value) {\n    /** @type {Node} */\n    var node = {type: String(type)}\n\n    if (\n      (value === undefined || value === null) &&\n      (typeof props === 'string' || Array.isArray(props))\n    ) {\n      value = props\n    } else {\n      Object.assign(node, props)\n    }\n\n    if (Array.isArray(value)) {\n      node.children = value\n    } else if (value !== undefined && value !== null) {\n      node.value = String(value)\n    }\n\n    return node\n  }\n)\n","/**\n * @typedef {import('xast').Root} Root\n * @typedef {import('xast').Element} Element\n * @typedef {Root['children'][number]} Child\n * @typedef {Child|Root} Node\n * @typedef {Root|Element} XResult\n * @typedef {string|number|boolean|null|undefined} XValue\n * @typedef {{[attribute: string]: XValue}} XAttributes Attributes to support JS primitive types\n *\n * @typedef {string|number|null|undefined} XPrimitiveChild\n * @typedef {Array.<Node|XPrimitiveChild>} XArrayChild\n * @typedef {Node|XPrimitiveChild|XArrayChild} XChild\n * @typedef {import('./jsx-classic').Element} x.JSX.Element\n * @typedef {import('./jsx-classic').IntrinsicAttributes} x.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic').IntrinsicElements} x.JSX.IntrinsicElements\n * @typedef {import('./jsx-classic').ElementChildrenAttribute} x.JSX.ElementChildrenAttribute\n */\n\n/**\n * Create XML trees in xast.\n *\n * @param name Qualified name. Case sensitive and can contain a namespace prefix (such as `rdf:RDF`). Pass `null|undefined` to build a root.\n * @param attributes Map of attributes. Nullish (null or undefined) or NaN values are ignored, other values (strings, booleans) are cast to strings.\n * @param children (Lists of) child nodes. When strings are encountered, they are mapped to Text nodes.\n */\nexport const x =\n  /**\n   * @type {{\n   *   (): Root\n   *   (name: null|undefined, ...children: XChild[]): Root\n   *   (name: string, attributes: XAttributes, ...children: XChild[]): Element\n   *   (name: string, ...children: XChild[]): Element\n   * }}\n   */\n  (\n    /**\n     * Hyperscript compatible DSL for creating virtual xast trees.\n     *\n     * @param {string|null} [name]\n     * @param {XAttributes|XChild} [attributes]\n     * @param {XChild[]} children\n     * @returns {XResult}\n     */\n    function (name, attributes, ...children) {\n      var index = -1\n      /** @type {XResult} */\n      var node\n      /** @type {string} */\n      var key\n\n      if (name === undefined || name === null) {\n        node = {type: 'root', children: []}\n        // @ts-ignore Root builder doesnâ€™t accept attributes.\n        children.unshift(attributes)\n      } else if (typeof name === 'string') {\n        node = {type: 'element', name, attributes: {}, children: []}\n\n        if (isAttributes(attributes)) {\n          for (key in attributes) {\n            // Ignore nullish and NaN values.\n            if (\n              attributes[key] !== undefined &&\n              attributes[key] !== null &&\n              (typeof attributes[key] !== 'number' ||\n                !Number.isNaN(attributes[key]))\n            ) {\n              // @ts-ignore Pretty sure we just set it.\n              node.attributes[key] = String(attributes[key])\n            }\n          }\n        } else {\n          children.unshift(attributes)\n        }\n      } else {\n        throw new TypeError('Expected element name, got `' + name + '`')\n      }\n\n      // Handle children.\n      while (++index < children.length) {\n        addChild(node.children, children[index])\n      }\n\n      return node\n    }\n  )\n\n/**\n * @param {Array.<Child>} nodes\n * @param {XChild} value\n */\nfunction addChild(nodes, value) {\n  var index = -1\n\n  if (value === undefined || value === null) {\n    // Empty.\n  } else if (typeof value === 'string' || typeof value === 'number') {\n    nodes.push({type: 'text', value: String(value)})\n  } else if (Array.isArray(value)) {\n    while (++index < value.length) {\n      addChild(nodes, value[index])\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children)\n    } else {\n      nodes.push(value)\n    }\n  } else {\n    throw new TypeError('Expected node, nodes, string, got `' + value + '`')\n  }\n}\n\n/**\n * @param {XAttributes|XChild} value\n * @returns {value is XAttributes}\n */\nfunction isAttributes(value) {\n  if (\n    value === null ||\n    value === undefined ||\n    typeof value !== 'object' ||\n    Array.isArray(value)\n  ) {\n    return false\n  }\n\n  return true\n}\n","/**\n * @typedef {import('./index.js').Parent} Parent\n * @typedef {import('./index.js').Context} Context\n * @typedef {import('./index.js').Child} Child\n */\n\nimport {one} from './one.js'\n\n/**\n * Serialize all children of `parent`.\n *\n * @param {Parent} parent\n * @param {Context} ctx\n * @returns {string}\n *\n */\nexport function all(parent, ctx) {\n  /** @type {Array.<Child>} */\n  var children = (parent && parent.children) || []\n  var index = -1\n  /** @type {Array.<string>} */\n  var results = []\n\n  while (++index < children.length) {\n    results[index] = one(children[index], ctx)\n  }\n\n  return results.join('')\n}\n","/**\n * @typedef {Object} CoreOptions\n * @property {string[]} [subset=[]]\n *   Whether to only escape the given subset of characters.\n * @property {boolean} [escapeOnly=false]\n *   Whether to only escape possibly dangerous characters.\n *   Those characters are `\"`, `&`, `'`, `<`, `>`, and `` ` ``.\n *\n * @typedef {Object} FormatOptions\n * @property {(code: number, next: number, options: CoreWithFormatOptions) => string} format\n *   Format strategy.\n *\n * @typedef {CoreOptions & FormatOptions & import('./util/format-smart.js').FormatSmartOptions} CoreWithFormatOptions\n */\n\n/**\n * Encode certain characters in `value`.\n *\n * @param {string} value\n * @param {CoreWithFormatOptions} options\n * @returns {string}\n */\nexport function core(value, options) {\n  value = value.replace(\n    options.subset ? charactersToExpression(options.subset) : /[\"&'<>`]/g,\n    basic\n  )\n\n  if (options.subset || options.escapeOnly) {\n    return value\n  }\n\n  return (\n    value\n      // Surrogate pairs.\n      .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, surrogate)\n      // BMP control characters (C0 except for LF, CR, SP; DEL; and some more\n      // non-ASCII ones).\n      .replace(\n        // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape\n        /[\\x01-\\t\\v\\f\\x0E-\\x1F\\x7F\\x81\\x8D\\x8F\\x90\\x9D\\xA0-\\uFFFF]/g,\n        basic\n      )\n  )\n\n  /**\n   * @param {string} pair\n   * @param {number} index\n   * @param {string} all\n   */\n  function surrogate(pair, index, all) {\n    return options.format(\n      (pair.charCodeAt(0) - 0xd800) * 0x400 +\n        pair.charCodeAt(1) -\n        0xdc00 +\n        0x10000,\n      all.charCodeAt(index + 2),\n      options\n    )\n  }\n\n  /**\n   * @param {string} character\n   * @param {number} index\n   * @param {string} all\n   */\n  function basic(character, index, all) {\n    return options.format(\n      character.charCodeAt(0),\n      all.charCodeAt(index + 1),\n      options\n    )\n  }\n}\n\n/**\n * @param {string[]} subset\n * @returns {RegExp}\n */\nfunction charactersToExpression(subset) {\n  /** @type {string[]} */\n  const groups = []\n  let index = -1\n\n  while (++index < subset.length) {\n    groups.push(subset[index].replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&'))\n  }\n\n  return new RegExp('(?:' + groups.join('|') + ')', 'g')\n}\n","/**\n * The smallest way to encode a character.\n *\n * @param {number} code\n * @returns {string}\n */\nexport function formatBasic(code) {\n  return '&#x' + code.toString(16).toUpperCase() + ';'\n}\n","import {stringifyEntitiesLight} from 'stringify-entities'\n\nvar noncharacter = /[\\u0000-\\u0008\\u000B\\u000C\\u000E-\\u001F]/g\n\n/**\n * Escape a string.\n *\n * @param {string} value\n * @param {Array.<string>} subset\n * @param {RegExp} [unsafe]\n * @returns {string}\n */\nexport function escape(value, subset, unsafe) {\n  var result = clean(value)\n\n  return unsafe ? result.replace(unsafe, encode) : encode(result)\n\n  /**\n   * @param {string} $0\n   * @returns {string}\n   */\n  function encode($0) {\n    return stringifyEntitiesLight($0, {subset})\n  }\n}\n\n/**\n * @param {string} value\n * @returns {string}\n */\nfunction clean(value) {\n  return String(value || '').replace(noncharacter, '')\n}\n","/**\n * @typedef {import('./core.js').CoreOptions & import('./util/format-smart.js').FormatSmartOptions} Options\n * @typedef {import('./core.js').CoreOptions} LightOptions\n */\n\nimport {core} from './core.js'\nimport {formatSmart} from './util/format-smart.js'\nimport {formatBasic} from './util/format-basic.js'\n\n/**\n * Encode special characters in `value`.\n *\n * @param {string} value\n *   Value to encode.\n * @param {Options} [options]\n *   Configuration.\n * @returns {string}\n *   Encoded value.\n */\nexport function stringifyEntities(value, options) {\n  return core(value, Object.assign({format: formatSmart}, options))\n}\n\n/**\n * Encode special characters in `value` as hexadecimals.\n *\n * @param {string} value\n *   Value to encode.\n * @param {LightOptions} [options]\n *   Configuration.\n * @returns {string}\n *   Encoded value.\n */\nexport function stringifyEntitiesLight(value, options) {\n  return core(value, Object.assign({format: formatBasic}, options))\n}\n","import {escape} from './util-escape.js'\n\nvar subset = ['\\t', '\\n', ' ', '\"', '&', \"'\", '/', '<', '=', '>']\n\n/**\n * Serialize a node name.\n *\n * @param {string} value\n * @returns {string}\n */\nexport function name(value) {\n  return escape(value, subset)\n}\n","/**\n * Count how often a character (or substring) is used in a string.\n *\n * @param {string} value\n *   Value to search in.\n * @param {string} character\n *   Character (or substring) to look for.\n * @return {number}\n *   Number of times `character` occurred in `value`.\n */\nexport function ccount(value, character) {\n  const source = String(value)\n\n  if (typeof character !== 'string') {\n    throw new TypeError('Expected character')\n  }\n\n  let count = 0\n  let index = source.indexOf(character)\n\n  while (index !== -1) {\n    count++\n    index = source.indexOf(character, index + character.length)\n  }\n\n  return count\n}\n","/**\n * @typedef {import('./index.js').Context} Context\n */\n\nimport {ccount} from 'ccount'\nimport {escape} from './util-escape.js'\n\n/**\n * Serialize an attribute value.\n *\n * @param {string} value\n * @param {Context} ctx\n * @returns {string}\n */\nexport function value(value, ctx) {\n  var primary = ctx.quote\n  var secondary = ctx.alternative\n  var result = String(value)\n  var quote =\n    secondary && ccount(result, primary) > ccount(result, secondary)\n      ? secondary\n      : primary\n\n  return quote + escape(result, ['<', '&', quote]) + quote\n}\n","/**\n * @typedef {import('./index.js').Handle} Handle\n * @typedef {import('./index.js').Element} Element\n * @typedef {import('./index.js').Attributes} Attributes\n */\n\nimport {all} from './all.js'\nimport {name} from './name.js'\nimport {value} from './value.js'\n\nvar own = {}.hasOwnProperty\n\n/**\n * Serialize an element.\n *\n * @type {Handle}\n * @param {Element} node\n */\nexport function element(node, ctx) {\n  var nodeName = name(node.name)\n  var content = all(node, ctx)\n  /** @type {Attributes} */\n  var attributes = node.attributes || {}\n  var close = content ? false : ctx.close\n  /** @type {Array.<string>} */\n  var attrs = []\n  /** @type {string} */\n  var key\n  /** @type {Attributes[keyof Attributes]} */\n  var result\n\n  for (key in attributes) {\n    if (own.call(attributes, key)) {\n      result = attributes[key]\n\n      if (result !== null && result !== undefined) {\n        attrs.push(name(key) + '=' + value(result, ctx))\n      }\n    }\n  }\n\n  return (\n    '<' +\n    nodeName +\n    (attrs.length === 0 ? '' : ' ' + attrs.join(' ')) +\n    (close ? (ctx.tight ? '' : ' ') + '/' : '') +\n    '>' +\n    content +\n    (close ? '' : '</' + nodeName + '>')\n  )\n}\n","/**\n * @typedef {import('./index.js').Handle} Handle\n * @typedef {import('./index.js').Text} Text\n */\n\nimport {escape} from './util-escape.js'\n\nvar subset = ['&', '<']\n\n/**\n * Serialize a text.\n *\n * @type {Handle}\n * @param {Text} node\n */\nexport function text(node) {\n  return escape(node.value, subset)\n}\n","/**\n * @typedef {import('./index.js').Handle} Handle\n * @typedef {import('./index.js').Instruction} Instruction\n */\n\nimport {escape} from './util-escape.js'\nimport {name} from './name.js'\n\nvar unsafe = /\\?>/g\nvar subset = ['>']\n\n/**\n * Serialize an instruction.\n *\n * @type {Handle}\n * @param {Instruction} node\n */\nexport function instruction(node) {\n  var nodeName = name(node.name) || 'x'\n  var result = escape(node.value, subset, unsafe)\n  return '<?' + nodeName + (result ? ' ' + result : '') + '?>'\n}\n","/**\n * @typedef {import('./index.js').Handle} Handle\n * @typedef {import('./index.js').Cdata} Cdata\n */\n\nimport {escape} from './util-escape.js'\n\nvar unsafe = /]]>/g\nvar subset = ['>']\n\n/**\n * Serialize a CDATA section.\n *\n * @type {Handle}\n * @param {Cdata} node\n */\nexport function cdata(node) {\n  return '<![CDATA[' + escape(node.value, subset, unsafe) + ']]>'\n}\n","/**\n * @typedef {import('./index.js').Handle} Handle\n */\n\nimport {all} from './all.js'\nimport {element} from './element.js'\nimport {text} from './text.js'\nimport {comment} from './comment.js'\nimport {doctype} from './doctype.js'\nimport {instruction} from './instruction.js'\nimport {cdata} from './cdata.js'\nimport {raw} from './raw.js'\n\nvar own = {}.hasOwnProperty\n\nvar handlers = {\n  root: all,\n  element,\n  text,\n  comment,\n  doctype,\n  instruction,\n  cdata,\n  raw\n}\n\n/**\n * Serialize a node.\n *\n * @type {Handle}\n */\nexport function one(node, ctx) {\n  var type = node && node.type\n\n  if (!type) {\n    throw new Error('Expected node, not `' + node + '`')\n  }\n\n  if (!own.call(handlers, type)) {\n    throw new Error('Cannot compile unknown node `' + type + '`')\n  }\n\n  // @ts-ignore Hush, it works.\n  return handlers[type](node, ctx)\n}\n","/**\n * @typedef {import('./index.js').Handle} Handle\n * @typedef {import('./index.js').Comment} Comment\n */\n\nimport {escape} from './util-escape.js'\n\n/**\n * Serialize a comment.\n *\n * @type {Handle}\n * @param {Comment} node\n */\nexport function comment(node) {\n  return '<!--' + escape(node.value, ['-']) + '-->'\n}\n","/**\n * @typedef {import('./index.js').Handle} Handle\n * @typedef {import('./index.js').Doctype} Doctype\n */\n\nimport {name} from './name.js'\nimport {value} from './value.js'\n\n/**\n * Serialize a doctype.\n *\n * @type {Handle}\n * @param {Doctype} node\n */\nexport function doctype(node, ctx) {\n  var nodeName = name(node.name)\n  var pub = node.public\n  var sys = node.system\n  var result = '<!DOCTYPE'\n\n  if (nodeName !== '') {\n    result += ' ' + nodeName\n  }\n\n  if (pub !== null && pub !== undefined && pub !== '') {\n    result += ' PUBLIC ' + value(pub, ctx)\n  } else if (sys !== null && sys !== undefined && sys !== '') {\n    result += ' SYSTEM'\n  }\n\n  if (sys !== null && sys !== undefined && sys !== '') {\n    result += ' ' + value(sys, ctx)\n  }\n\n  return result + '>'\n}\n","/**\n * @typedef {import('./index.js').Handle} Handle\n * @typedef {import('./index.js').Raw} Raw\n */\n\nimport {text} from './text.js'\n\n/**\n * Serialize a (non-standard) raw.\n *\n * @type {Handle}\n * @param {Raw} node\n */\nexport function raw(node, ctx) {\n  // @ts-ignore Looks like a text.\n  return ctx.dangerous ? node.value : text(node)\n}\n","/**\n * @typedef {import('xast').Root} Root\n * @typedef {import('xast').Element} Element\n * @typedef {import('xast').Cdata} Cdata\n * @typedef {import('xast').Comment} Comment\n * @typedef {import('xast').Doctype} Doctype\n * @typedef {import('xast').Instruction} Instruction\n * @typedef {import('xast').Text} Text\n * @typedef {import('xast').Literal & {type: 'raw'}} Raw\n * @typedef {Root|Element} Parent\n * @typedef {import('xast').Attributes} Attributes\n * @typedef {Root['children'][number]} Child\n * @typedef {Child|Root} Node\n *\n * @typedef {'\"'|\"'\"} Quote\n *\n * @typedef Options\n * @property {Quote} [quote='\"'] Preferred quote to use\n * @property {boolean} [quoteSmart=false] Use the other quote if that results in\n *   less bytes\n * @property {boolean} [closeEmptyElements=false] Close elements without any\n *   content with slash (/) on the opening tag instead of an end tag:\n *   `<circle />` instead of `<circle></circle>`.\n *   See `tightClose` to control whether a space is used before the slash.\n * @property {boolean} [tightClose=false] Do not use an extra space when closing\n *    self-closing elements: `<circle/>` instead of `<circle />`.\n * @property {boolean} [allowDangerousXml=false] Allow `raw` nodes and insert\n *   them as raw XML. When falsey, encodes `raw` nodes.\n *   Only set this if you completely trust the content!\n *\n * @typedef Context\n * @property {Quote} quote\n * @property {Quote} alternative\n * @property {boolean} close\n * @property {boolean} tight\n * @property {boolean} dangerous\n *\n * @callback Handle\n * @param {Node} node\n * @param {Context} context\n * @returns {string}\n */\n\nimport {one} from './one.js'\n\n/**\n * Serialize the given xast tree (or list of nodes).\n *\n * @param {Node|Array.<Node>} node\n * @param {Options} [options]\n * @returns {string}\n */\nexport function toXml(node, options = {}) {\n  var quote = options.quote || '\"'\n  /** @type {Quote} */\n  var alternative = quote === '\"' ? \"'\" : '\"'\n  var smart = options.quoteSmart\n  /** @type {Node} */\n  // @ts-ignore Assume no `root` in `node`.\n  var value = Array.isArray(node) ? {type: 'root', children: node} : node\n\n  if (quote !== '\"' && quote !== \"'\") {\n    throw new Error('Invalid quote `' + quote + '`, expected `\\'` or `\"`')\n  }\n\n  return one(value, {\n    dangerous: options.allowDangerousXml,\n    close: options.closeEmptyElements,\n    tight: options.tightClose,\n    quote,\n    alternative: smart ? alternative : null\n  })\n}\n","import { u } from 'unist-builder';\nimport { x } from 'xastscript';\nimport type { Element } from 'xast';\nimport type { Root, Folder } from '@tmcw/togeojson';\nimport type { Feature, FeatureCollection, Geometry, Position } from 'geojson';\nimport { toXml } from 'xast-util-to-xml';\n\ntype F = Feature<Geometry | null>;\n\nconst BR = u('text', '\\n');\nconst TAB = u('text', '  ');\n\ntype Literal = typeof BR;\n\n/**\n * Convert nested folder structure to KML. This expects\n * input that follows the same patterns as [toGeoJSON](https://github.com/placemark/togeojson)'s\n * kmlWithFolders method: a tree of folders and features,\n * starting with a root element.\n */\nexport function foldersToKML(root: Root): string {\n  return toXml(\n    u('root', [\n      x(\n        'kml',\n        { xmlns: 'http://www.opengis.net/kml/2.2' },\n        x(\n          'Document',\n          root.children.flatMap((child) => convertChild(child))\n        )\n      ),\n    ])\n  );\n}\n\n/**\n * Convert a GeoJSON FeatureCollection to a string of\n * KML data.\n */\nexport function toKML(\n  featureCollection: FeatureCollection<Geometry | null>\n): string {\n  return toXml(\n    u('root', [\n      x(\n        'kml',\n        { xmlns: 'http://www.opengis.net/kml/2.2' },\n        x(\n          'Document',\n          featureCollection.features.flatMap((feature) =>\n            convertFeature(feature)\n          )\n        )\n      ),\n    ])\n  );\n}\n\nfunction convertChild(child: F | Folder) {\n  switch (child.type) {\n    case 'Feature':\n      return convertFeature(child);\n    case 'folder':\n      return convertFolder(child);\n  }\n}\n\nfunction convertFolder(folder: Folder): Array<Literal | Element> {\n  const id = ['string', 'number'].includes(typeof folder.meta.id)\n    ? {\n        id: String(folder.meta.id),\n      }\n    : {};\n  return [\n    BR,\n    x('Folder', id, [\n      BR,\n      ...folderMeta(folder.meta),\n      BR,\n      TAB,\n      ...folder.children.flatMap((child) => convertChild(child)),\n    ]),\n  ];\n}\n\nconst META_PROPERTIES = [\n  'address',\n  'description',\n  'name',\n  'open',\n  'visibility',\n  'phoneNumber',\n] as const;\n\nfunction folderMeta(meta: Folder['meta']): Element[] {\n  return META_PROPERTIES.filter((p) => meta[p] !== undefined).map((p) => {\n    return x(p, [u('text', String(meta[p]))]);\n  });\n}\n\nfunction convertFeature(feature: F) {\n  const { id } = feature;\n  const idMember = ['string', 'number'].includes(typeof id)\n    ? {\n        id: id,\n      }\n    : {};\n  return [\n    BR,\n    x('Placemark', idMember, [\n      BR,\n      ...propertiesToTags(feature.properties),\n      BR,\n      TAB,\n      ...(feature.geometry ? [convertGeometry(feature.geometry)] : []),\n    ]),\n  ];\n}\n\nfunction join(position: Position): string {\n  return `${position[0]},${position[1]}`;\n}\n\nfunction coord1(coordinates: Position): Element {\n  return x('coordinates', [u('text', join(coordinates))]);\n}\n\nfunction coord2(coordinates: Position[]): Element {\n  return x('coordinates', [u('text', coordinates.map(join).join('\\n'))]);\n}\n\nfunction toString(value: any): string {\n  switch (typeof value) {\n    case 'string': {\n      return value;\n    }\n    case 'boolean':\n    case 'number': {\n      return String(value);\n    }\n    case 'object': {\n      try {\n        return JSON.stringify(value);\n      } catch (e) {\n        return '';\n      }\n    }\n  }\n  return '';\n}\n\nfunction maybeCData(value: any) {\n  if (\n    value &&\n    typeof value === 'object' &&\n    '@type' in value &&\n    value['@type'] === 'html' &&\n    'value' in value &&\n    typeof value.value === 'string'\n  ) {\n    return u('cdata', value.value);\n  }\n\n  return toString(value);\n}\n\nfunction propertiesToTags(properties: Feature['properties']): Element[] {\n  if (!properties) return [];\n  const { name, description, visibility, ...otherProperties } = properties;\n\n  return [\n    name && x('name', [u('text', toString(name))]),\n    description && x('description', [u('text', maybeCData(description))]),\n    visibility !== undefined &&\n      x('visibility', [u('text', visibility ? '1' : '0')]),\n    x(\n      'ExtendedData',\n      Object.entries(otherProperties).flatMap(([name, value]) => [\n        BR,\n        TAB,\n        x('Data', { name: name }, [\n          x('value', [\n            u(\n              'text',\n              typeof value === 'string' ? value : JSON.stringify(value)\n            ),\n          ]),\n        ]),\n      ])\n    ),\n  ].filter(Boolean);\n}\n\nconst linearRing = (ring: Position[]): Element =>\n  x('LinearRing', [coord2(ring)]);\n\nfunction convertMultiPoint(geometry: GeoJSON.MultiPoint): Element {\n  return x(\n    'MultiGeometry',\n    geometry.coordinates.flatMap((coordinates) => [\n      BR,\n      convertGeometry({\n        type: 'Point',\n        coordinates,\n      }),\n    ])\n  );\n}\nfunction convertMultiLineString(geometry: GeoJSON.MultiLineString): Element {\n  return x(\n    'MultiGeometry',\n    geometry.coordinates.flatMap((coordinates) => [\n      BR,\n      convertGeometry({\n        type: 'LineString',\n        coordinates,\n      }),\n    ])\n  );\n}\n\nfunction convertMultiPolygon(geometry: GeoJSON.MultiPolygon): Element {\n  return x(\n    'MultiGeometry',\n    geometry.coordinates.flatMap((coordinates) => [\n      BR,\n      convertGeometry({\n        type: 'Polygon',\n        coordinates,\n      }),\n    ])\n  );\n}\n\nfunction convertPolygon(geometry: GeoJSON.Polygon): Element {\n  const [outerBoundary, ...innerRings] = geometry.coordinates;\n  return x('Polygon', [\n    BR,\n    x('outerBoundaryIs', [BR, TAB, linearRing(outerBoundary)]),\n    ...innerRings.flatMap((innerRing) => [\n      BR,\n      x('innerBoundaryIs', [BR, TAB, linearRing(innerRing)]),\n    ]),\n  ]);\n}\n\nfunction convertGeometry(geometry: Geometry): Element {\n  switch (geometry.type) {\n    case 'Point':\n      return x('Point', [coord1(geometry.coordinates)]);\n    case 'MultiPoint':\n      return convertMultiPoint(geometry);\n    case 'LineString':\n      return x('LineString', [coord2(geometry.coordinates)]);\n    case 'MultiLineString':\n      return convertMultiLineString(geometry);\n    case 'Polygon':\n      return convertPolygon(geometry);\n    case 'MultiPolygon':\n      return convertMultiPolygon(geometry);\n    case 'GeometryCollection':\n      return x(\n        'MultiGeometry',\n        geometry.geometries.flatMap((geometry) => [\n          BR,\n          convertGeometry(geometry),\n        ])\n      );\n  }\n}\n"],"names":["u","type","props","value","node","String","Array","isArray","Object","assign","children","x","name","attributes","key","index","unshift","TypeError","isAttributes","undefined","Number","isNaN","length","addChild","nodes","push","all","parent","ctx","results","one","join","core","options","replace","subset","groups","RegExp","charactersToExpression","basic","escapeOnly","pair","format","charCodeAt","character","formatBasic","code","toString","toUpperCase","noncharacter","escape","unsafe","result","clean","encode","$0","stringifyEntitiesLight","ccount","source","count","indexOf","primary","quote","secondary","alternative","own","hasOwnProperty","text","handlers","root","element","nodeName","content","close","attrs","call","tight","comment","doctype","pub","public","sys","system","instruction","cdata","raw","dangerous","Error","toXml","smart","quoteSmart","allowDangerousXml","closeEmptyElements","tightClose","BR","TAB","convertChild","child","convertFeature","folder","id","includes","meta","folderMeta","flatMap","convertFolder","META_PROPERTIES","filter","p","map","feature","idMember","propertiesToTags","properties","geometry","convertGeometry","position","coord2","coordinates","JSON","stringify","e","maybeCData","description","visibility","otherProperties","entries","Boolean","linearRing","ring","convertMultiPoint","convertMultiLineString","outerBoundary","innerRings","innerRing","convertPolygon","convertMultiPolygon","geometries","xmlns","featureCollection","features"],"mappings":"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"}